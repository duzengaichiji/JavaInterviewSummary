# mysql的锁

----------
- 锁粒度
> myIsam的锁默认是加表锁（锁住整个数据表），Innodb默认是加行锁（锁某个数据行）；
> 
> 表锁，开销小，加锁快，**不会出现死锁**，粒度更粗，并发度低，主要以查询为主；表锁锁的是数据文件
> 
> 行锁：开销大，慢，会出现死锁，粒度细，并发度更高；行锁锁定的是**索引**；
- 共享锁，排他锁
> 共享锁即读锁，其他线程可以读，但不能写；
> 
> 排他锁即写锁，其他线程不可以读；
> 
> 默认情况下，写锁定有更高的优先级，当数据的锁释放时，会优先给队列中的写锁请求；
> 
- 间隙锁
> 当使用范围查询并进行锁定时，即便查询范围中有当前数据中没有的部分，这部分也会被锁定（即插入这部分数据的请求会被阻塞）；
> 
> 使用间隙锁可以 防止幻读，满足恢复和复制的需求；
- 死锁
> 多个事务在同一资源（同一个表/同一些行）相互占用并且请求锁定对方以及占用的资源从而导致环形调用时形成死锁
> 
> （事务1：锁定行1，修改行2；事务2：锁定行2，修改行1）
> 
> 死锁避免：由于myIsam总是一次性获得sql所需要的所有锁，因此不会有死锁现象；
> 
> 对于innoDb：
> 
>   1. 可以在开始便锁定之后可能操作的所有行的锁
> 
>   2. 有更新的需要，选择写锁
>
- 乐观锁，悲观锁
> 乐观锁：假设不会发生并发冲突，只在提交的时候检查是否违法数据完整性，不能解决脏读问题
> 
> 悲观锁：假设必定发生并发冲突，取数据的时候都认为数据会修改，直接加锁(读锁，写锁等都是悲观锁，它们都不允许其他事务修改)