# mysql的事务与log

----------
 - 事务的四大特性
> 一致性，原子性，隔离性，持久性
> 

> 这里用一个例子表达四个特性的意思：
> 
> A向B转账500，必须完成A的账户-500，B的账户+500，中间不能被打断，否则会出现数据不一致的问题（A-500，B没有加到，则二者数据相加为0，数据**一致性**丢失）。所以该操作必须保证**原子性**，要么二者都完成，要么就都不完成，完全回滚。另外，一次事务不能被其他事务干扰（**隔离性**），比如此时C也向B转账300，B应该拥有800，但因为同时读取了B的账户数据0，写回时候C的转账后完成，导致写回B时B的账户只有300（受到并发的影响）。此外，转账完成后，双方账号永久性修改（**持久性**）。
> 
> 
 - 事务隔离性问题的隔离级别
> 脏读：指的是一个事务读取到了另一个事务未提交的数据（乐观锁显然无法避免这个，因为乐观锁并不阻止其他事务修改数据）
> 
> 不可重复读：一个事务内多次查询同一数据，值却不同（因为被其他事务修改了）
> 
> 幻读：指的是一个事务读到了本不该出现的数据（比如一个事务内前后两次select出来的数据不同，显然，间隙锁可以解决这个问题）；
> 

> 未提交读：读不加锁，写的时候加共享锁（因此未提交的修改会被别的事务读到）
> 
> 已提交读：读的时候加共享锁，读完数据释放；写的时候加写锁；（由于读的时候加了读锁，可以避免 脏读，但由于读完立马释放，所以下次读取的时候仍可能发生 不可重复读，幻读）
> 
> 可重复读：对读取的数据加共享锁**直到事务结束**，对修改的数据加排他锁直到事务结束；（显然，这个避免了不可重复读，因为将共享锁从头加到尾了，但是对于幻读
> 如果加的不是间隙锁，仍然可能出现幻读）
>

> 其中，innodb的已提交读在读数据的时，并不是通过加共享锁实现的。而是通过mVCC快照机制；
> 
> 即每次读取都是读取数据快照，而不是加锁，因此显然不能解决不可重复读和幻读；
> 
 - 各种log，它们与事务的关系
> 1、binlog
> 
> 记录了数据的变更（update/delete/insert/create），主要用于数据库的主从复制和数据恢复；
> 
> binlog记录了这些语句，就相当于执行日志；
> 
> 2.redolog
> 
> 当某条语句进行了数据修改，会先更改内存中的数据，然后**写一份redo log**到磁盘，最后再更新磁盘数据；
> 
> redolog记录了**磁盘上被修改的页**，当数据被刷到磁盘上时，redolog就失效了；显然，当整个数据库被删除的时候，要用bin log而不是redo log去修复，即按照bin log去再完整执行一遍；
> 
> 这样一来，假设还没更新磁盘的时候，数据库挂了，就可以靠redo log进行恢复（保证持久性）
> 
> 通常，修改语句在修改内存的同时，会先写下redo log，然后在事务提交的时候才会写入bin log；任意一个log写入失败，就会进行回滚；
> 
> 3.undo log
>  
> 除了上述两种log，还会记录undo log，undo log就是拿去回滚的；