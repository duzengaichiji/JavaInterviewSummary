 # volatile关键字
 ----------
- 可见性
>
> 背景：JMM规定所有的变量都存储在主存中，每个线程在自己的工作内存（通常就是cache）中保持主存中的变量的副本；
> 由于各个工作线程的工作内存互相隔离，因此必须将变量刷到主存的变量中，其他的线程才能感知并同步；
> 
> volatile作用于共享变量，某些情况下比锁（sychronized）更方便；
> 
> 如果一个字段被声明为volatile，所有线程看到的这个变量都是**一致的**；
> 

> 有volatile声明的变量，在写操作时会引发：
> 
> 1.将当前处理器的缓存行的数据**写回到系统内存**；
> 
> 2.写回到内存的操作会使其他cpu里缓存了该内存地址的数据无效；
> 
> 由于cpu总是将内存数据加载到告诉缓存（cache）中，并和cache进行交互；
> 
> 被volatile修饰的变量，各个处理器会通过在总线上传播的数据来检查自己那份缓存是否过期了；
> 
> 如果发现自己那份缓存过期了，则会强制去读取内存中的变量，然后更新自己的缓存；
> 
 
> 
> 写屏障：写指令之前插入写屏障，能让写入缓存的最新数据写回主存（可见性的实现）；
> 
> 读屏障：读指令前插入读屏障，让高速缓存中的数据失效，重新从主从中加载；
> 
- 有序性
> volatile变量通过在指令序列中添加 **内存屏障** 禁止指令重排序；
>
- 原子性 
> volatile不保证原子性，显然，它又不能阻止并发修改；
> 
- 应用
> 二次检测的单例模式