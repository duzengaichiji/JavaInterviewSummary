# Java类的生命周期
相关代码：JVM
----------

> 通常来说，一个java类（指已经完成编译的.class文件），整个生命周期，可以分为七个阶段：
> 
> 加载-验证-准备-解析-初始化-使用-卸载
> 
> 其中，验证-准备-解析 又可以合起来称为连接阶段；
> 
> 需要注意的是，这几个阶段是按这个顺序开始的，**但是不一定是按这个顺序依次进行或者完成的**,各个阶段之间，可能存在交叉进行的关系；
> 
> 

----------
 - 1 类加载
 
 > 类的加载过程就是将.class字节码文件载入到虚拟机中，并转化为Class对象，存放在元空间中；
 > 该过程的执行者就是类加载器；
 > 
 > 通常，将类加载器大致分为两类，系统定义的类加载器，自定义类加载器；
 >
 > 其中，系统定义的加载器主要指的是，引导类加载器（boostrap classloader）,额外类加载（extension classloader），应用程序类加载器（application classloader），
 > 三者之间是包含关系，即可boostrap是extension的上级，extension是application的上级；
 ----------
 > 引导类加载器主要用来加载java核心库（jre/lib,jre/lib/rt.jar），为整个jvm提供支持；
 > 
 > 额外类加载器主要用于加载jdk目录下jre/lib/extl里面的库；
 > 
 > 应用程序类加载器，通常用于加载用户自己编写的类，是jvm默认使用的加载器；
 >
 > 不同的类加载器管理着不同的**命名空间**
 >
 > **关于双亲委派机制**
 > 
 > 主要指的是，一个类加载器在收到一个类加载请求的时候，会先请示上层加载器，如果上层加载器可以加载这个类，则由上层加载器来加载（同样的，上层也会请示
 > 它自己的上层，这是一个递归的过程，通常都会一路委托到引导类加载器）,如果上层无法加载，才有自己进行加载；
 >
 > 这么做的目的是：
 > 
 > 1.确保一个类在**同一个类加载器中**具有唯一性，但是，不同加载器中是允许同名的类存在的；即使全类名相同的两个类，jvm中会对比其类加载器，
 > 如果不同，它们仍然会被判别为不同的类；
 > 
 > 2.防止重复加载同一个类，因为某个类可能上层加载器已经加载过了，所以进行询问来避免；
 > 
 > 3.保证核心类库的安全性，由于核心类库里面的类只会由引导类加载器加载，所以自己定义java.lang.*这样的类，想要去替换jre/lib里面的类，是做不到的；
  ----------
   - 2 验证
   
 > 验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全，防止虚拟机被恶意代码攻击；
 > 主要包括：文件格式验证，数据源验证，字节码验证，符号引用验证；
   ----------

   - 3 准备
 > 准备阶段主要是为类的**静态变量**分配内存空间，并设置为jvm默认的初值（注意这个值不是代码中给定的值），对于其他成员变量，则是后面生成对象
 > 的时候才会确定值，此时也不会为它们分配内存（这很容易理解，因为静态变量是属于类的变量，所以应当和类存放在一起，即**静态变量表**存放在元空间，
 > 而成员变量则是属于对象的，应存放在堆空间中）；
 ----------
- 4 解析
 > 虚拟机将常量池中的符号引用替换为直接引用，解析主要针对类或接口，字段，方法等。
 >
----------
- 5 初始化
 > 这个阶段，才真正执行了程序代码；
 >
 > 该阶段会调用类的构造器，执行构造器里面的代码，并且为成员变量分配空间以及赋值；
 > 
 > 通常来说，执行顺序是这样的；
 >
 > 父类的静态代码块-子类的静态代码块-父类的初始化块（非静态代码块）-父类的构造器-子类的初始化块-子类的构造器
 >
 > 但实际情况，会根据使用方式和需求有所不同（主要设计jvm的内部优化）
 
    public class FatherClass {
        static{
            System.out.println("父类初始化");
        }
        public static final int value = 323;
    } 
    
    public class ChildClass extends FatherClass{
        static {
            System.out.println("子类被加载");
        }
    }
    
    public void classLoaderTest1(){
        // 父类初始化
        // 323
        System.out.println(ChildClass.value);
    }
 > 可以看到，只调用了父类的静态代码块，那是因为，对于静态字段的访问，只有直接定义这个字段的类
 > 才会被初始化，所以这里没有访问子类的静态代码块；
    
    public void classLoaderTest2(){
        // 什么也不会输出
        FatherClass fc[] = new FatherClass[10];
    }
 > 因为这段代码并未触发jvm.FatherClass的初始化阶段，而是触发了Lorg.FatherClass的初始化。。这个类代表了一个元素类型未jvm.FatherClass的一维数组;
 > 
 > 这也很显然，因为这里只定义了一个FatherClass数组，而并未真正的对其引用创建FatherClass对象，即这里面不涉及jvm.FatherClass对象的初始化；
 
    FatherClass fc[] = new FatherClass[10];
    for (int i = 0; i < 10; i++) {
        fc[i] = new FatherClass();
    }
 > 改成这样就会触发了；
 
    public class FatherClass {
        static{
            System.out.println("父类初始化");
        }
        public static final int value = 323;
    }
    
    public void classLoaderTest3(){
        // 323
        System.out.println(FatherClass.value);
    }
 > 这里和上面的区别是将value定义为final类型，会在编译阶段触发**常量传播优化**，编译时就将常量value存放到Test类常量池中，这里的FatherClass.value会
 > 直接引用常量池中的value，不会触发FatherClass的初始化过程；
----------
- 6 使用
 > 
 >
----------
- 7 卸载
 > 即触发了元空间的垃圾回收，回收了这个类对应的Class对象；
 > 
 > 回收Class对象有比较严格的条件：
 > 
 > 1.该类的所有实例都已经被回收，堆中不存在此类的任何实例；
 > 
 > 2.该类的classLoader对象被回收；
 > 
 > 3.该Class对象已经没有被任何地方直接或间接引用，并且没有任何地方通过反射访问该Class对象；