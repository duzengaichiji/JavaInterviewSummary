# Java的一些基本概念和特性
相关代码 : javaBasic.CloneCase，JUC.WaitSleepCase.java

 - 1 平台无关性
> java编译器可以生成和计算机体系结构无关的字节码指令，字节码文件可以在任何机器上解释执行，这一过程通过JVM实现；
> 
> 对于用户来说，JVM屏蔽了各种操作系统底层的差别，而只需要关注java代码本身。

----------
 - 2 java的基本数据类型
> boolean 1byte
>
> byte 1byte
>
> char 2byte
>
> int 4byte
>
> float 4byte
>
> long 8byte
>
> double 8byte

 - 2.1 BigDecimal
> bigDecimal不属于基本类型，不能直接使用运算符，需要使用其实例方法add,substract等，进行运算；
> 
> 并且在进行除法运算时需要指定精度和舍入方式，否则会报错；
> 
> 和double比较，double比较容易出现精度丢失的问题，但是作为基本类型，使用方便，bigdecimal精度更高，但是效率更低下；
> 
> 涉及金额的数据最好使用bigdecimal来保证高精度；

 - 2.2 自动拆箱，装箱
> 所有的基本类型都有对应的包装类型，可以将基本类型的值赋予包装类，也可以将包装类的值赋予基本类型，这两个过程就是自动拆箱，装箱；
> 
> 设计包装类的原因是有些地方无法使用基本类型作为参数，要使用引用类型，此时只能用包装类型；
> 
> 两个包装类型相互比较的时候要用equals；


----------

 - 3 类，接口，抽象类
> 接口不能被实例化，类，抽象类都可以；
> 
> 抽象类如果要被实例化，必须指向已经实现了所有抽象方法的子类对象，或者直接在实例化的时候实现所有抽象方法；
> 
> 接口里面只能做方法的声明，抽象类可以做方法的声明，也可以做方法的实现；
> 
> 接口里面只能定义public static的类变量，抽象类可以定义成员变量；
> 
> 接口的访问权限只能定义为public；
> 
> 一个类可以实现狠多个接口，但是只能继承一个类；
> 
> **子类方法覆盖父类方法时，访问权限必须比父类的小（即父类如果是protected，那么子类方法必须至少是protected或者public）**

 - 3.1 定义类，方法的作用域public,private,protected,default
> public:可以在任何地方访问； 
>
> protected：可以在本类，本包内，不同包的子类下访问；
>
> default：可以在本类，本包内访问；
>
> private：只能在本类内访问；

 - 3.2 重载，重写
> 重载：写在同一个类中的同名但是不同参数列表的函数（比如多个构造器）
>
> 重写/覆盖：静态方法不能覆盖实例方法，反之也不行；
>
> 重写必须保证方法名，返回值，参数列表一致；
>
> 即子类的方法重写了父类相同方法的逻辑，如果是子类对象调用时就会调用子类的逻辑，而如果是父类对象则会调用父类的逻辑；


  - 3.3 子类加载顺序和初始化顺序
> 父类的静态代码块和静态变量； 
>
> 子类的静态代码块和静态变量；
>
> 父类的普通代码块和普通变量；
>
> 父类的构造方法；
> 
> 子类的普通代码块和普通变量；
>
> 子类的构造方法；
>  
（注意变量的初始化和构造方法调用的区别，初始化只是为变量分配了内存空间，而调用构造方法，会把具体的值赋给变量）

----------

 - 4 Object类中定义了哪些方法
> object类作为所有对象的祖先类，定义了如下方法：
>
> equals：默认的实现和==相同，即比较两个引用的内存地址，可以重写（如String重写了用来比较两个引用所指向的对象的值），重写equals通常伴随着重写hashCode方法；
>
> hashCode：使用对象的内存地址计算散列值；
>
> clone：实现了clonable接口的对象可以通过调用clone方法克隆自己，默认情况下clone实现的是浅拷贝；
>
> finalize：对象被销毁时自动调用，通常由GC线程调用；
>
> getClass：获取对象对应的Class对象，用于反射的各种操作；
>
> notify，notifyAll：唤醒在此对象监视器上的线程；
>
> wait，wait（time）：在其他线程调用notify之前，**放弃当前对象锁定**，进行等待；

 - 4.1 对象的浅拷贝与深拷贝

> 首先，创建对象有如下5种方式:
>
> 1.调用构造器，new一个对象；
>
> 2.通过class类调用newInstance方法（调用了无参构造器）；
>
> 3.通过class类型反射调用构造方法；
>
> 4.利用clone方法；
>
> 5.序列化/反序列化；
> 
> 默认情况下，调用clone方法，不会触发深拷贝；
>
> 举一个例子：一个Person对象里面有一个Address对象，这是一个引用类型，那么调用默认的clone方法，克隆person对象，会创建一个新的person对象，实例变量会重新创建，但是，其内部的address引用会和之前那个指向同一个对象（即可person1.address和person2.address指向同一个对象）；
>
> 需要深拷贝的话，需要将person1的address指向的对象进行克隆，然后让person2的address指向它；
另外，通过序列化和反序列化也能进行深拷贝

  - 4.2 wait和sleep的区别
> sleep使线程休眠固定的时间，不会放弃锁的使用权，其他抢占锁的线程将会阻塞，等待休眠结束后占有锁的线程执行完成；
> 而wait必须放在同步代码块中，wait会**释放**当前锁(其他线程可以申请这个锁定)，并且需要别的线程notify之后，该线程才会继续执行；
>
----------

 - 5 异常处理

> 抛出异常有三种形式，throw，throws，系统自动抛出异常；
throw是明确抛出一个异常，直接导致程序阻断或者进入异常处理，是写在方法体内的；
throws是修饰在方法名后面的，表示这段代码可能会抛出某种异常；
上述二者都需要try-Catch块进行异常处理；

 
 
 
